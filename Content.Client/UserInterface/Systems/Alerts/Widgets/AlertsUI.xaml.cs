using System.ComponentModel;
using Content.Client.UserInterface.Systems.Alerts.Controls;
using Content.Client.UserInterface.Systems.NativeActions.Widgets;
using Content.Shared.Alert;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Prototypes;

namespace Content.Client.UserInterface.Systems.Alerts.Widgets;

/// <summary>
///     The status effects display on the right side of the screen.
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class AlertsUI : UIWidget
{
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;

    // also known as Control.Children?
    private readonly Dictionary<AlertKey, AlertControl> _alertControls = new();

    private NativeActionsUIController _NAController;

    // Well, spagetti code.
    private NativeActionsGui? _nativeActionsGui
    {
        get => _NAController.NativeActions;
    }

    private BoxContainer? _mainAlertsContainer
    {
        get => _NAController.MainAlertsContainer;
    }

    public AlertsUI()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _NAController = UserInterfaceManager.GetUIController<NativeActionsUIController>();
    }

    public void SyncControls(AlertsSystem alertsSystem,
        AlertOrderPrototype? alertOrderPrototype,
        IReadOnlyDictionary<AlertKey,
        AlertState> alertStates)
    {
        // remove any controls with keys no longer present
        if (SyncRemoveControls(alertStates))
            return;

        // now we know that alertControls contains alerts that should still exist but
        // may need to updated,
        // also there may be some new alerts we need to show.
        // further, we need to ensure they are ordered w.r.t their configured order
        SyncUpdateControls(alertsSystem, alertOrderPrototype, alertStates);
    }

    public void ClearAllControls()
    {
        foreach (var alertControl in _alertControls.Values)
        {
            alertControl.OnPressed -= AlertControlPressed;
            alertControl.Dispose();
        }

        _alertControls.Clear();
    }

    public event EventHandler<ProtoId<AlertPrototype>>? AlertPressed;

    private bool SyncRemoveControls(IReadOnlyDictionary<AlertKey, AlertState> alertStates)
    {
        var toRemove = new List<AlertKey>();
        foreach (var existingKey in _alertControls.Keys)
        {
            if (!alertStates.ContainsKey(existingKey))
                toRemove.Add(existingKey);
        }

        foreach (var alertKeyToRemove in toRemove)
        {
            _alertControls.Remove(alertKeyToRemove, out var control);
            if (control == null)
                return true;

            // If we wanna move some Alerts into another UI.
            control.Parent?.RemoveChild(control);
        }

        return false;
    }

    private Control EnsureControlsContainer(AlertKey alertKey)
    {
        var alertControlsContainer = (Control) AlertContainer;

        // If we wanna move some Alerts into another UI.
        // TODO: Move some definition into prototypes
        if (_prototypeManager.TryIndex<AlertCategoryPrototype>(alertKey.AlertCategory, out var alertCategory))
        {
            if (_nativeActionsGui == null)
                return alertControlsContainer;

            switch (alertCategory.Group)
            {
                case "NativeActions":
                    alertControlsContainer = _nativeActionsGui.ActionsContainer;
                    return alertControlsContainer;
                    break;
                case "Intents":
                    alertControlsContainer = _nativeActionsGui.IntentsContainer;
                    if (alertControlsContainer.ChildCount >= 2)
                    {
                        alertControlsContainer = _nativeActionsGui.IntentsContainer2;
                    }
                    return alertControlsContainer;
                    break;
                case "MainInfo":
                    if (_mainAlertsContainer != null)
                    {
                        alertControlsContainer = (Control) _mainAlertsContainer;
                        return alertControlsContainer;
                    }
                    break;
            }
        }

        // Try use another UI container. We append elements by manual.
        // Dirty, i know, but i dont' have any idea how to rework AlertsUI
        // TODO: Fuck, it should be rework.
        if (_NAController.LeftTopAlertContainer != null && // Left side
                    _NAController.LeftTopAlertContainer.ChildCount < 1)
            alertControlsContainer = _NAController.LeftTopAlertContainer;
        else if (_NAController.LeftMiddleAlertContainer != null &&
                    _NAController.LeftMiddleAlertContainer.ChildCount < 2)
            alertControlsContainer = _NAController.LeftMiddleAlertContainer;
        else if (_NAController.LeftBottomAlertContainer != null &&
                    _NAController.LeftBottomAlertContainer.ChildCount < 1)
            alertControlsContainer = _NAController.LeftBottomAlertContainer;
        else if (_NAController.RightTopAlertContainer != null && // Right side
                    _NAController.RightTopAlertContainer.ChildCount < 1)
            alertControlsContainer = _NAController.RightTopAlertContainer;
        else if (_NAController.RightMiddleAlertContainer != null &&
                    _NAController.RightMiddleAlertContainer.ChildCount < 2)
            alertControlsContainer = _NAController.RightMiddleAlertContainer;
        else if (_NAController.RightBottomAlertContainer != null &&
                    _NAController.RightBottomAlertContainer.ChildCount < 2)
            alertControlsContainer = _NAController.RightBottomAlertContainer;

        return alertControlsContainer;
    }

    private void SyncUpdateControls(AlertsSystem alertsSystem, AlertOrderPrototype? alertOrderPrototype,
        IReadOnlyDictionary<AlertKey, AlertState> alertStates)
    {
        foreach (var (alertKey, alertState) in alertStates)
        {
            if (!alertKey.AlertType.HasValue)
            {
                Logger.WarningS("alert", "found alertkey without alerttype," +
                                         " alert keys should never be stored without an alerttype set: {0}", alertKey);
                continue;
            }

            var alertType = alertKey.AlertType.Value;
            if (!alertsSystem.TryGet(alertType, out var newAlert))
            {
                Logger.ErrorS("alert", "Unrecognized alertType {0}", alertType);
                continue;
            }

            if (_alertControls.TryGetValue(newAlert.AlertKey, out var existingAlertControl) &&
                existingAlertControl.Alert.ID == newAlert.ID)
            {
                // key is the same, simply update the existing control severity / cooldown
                existingAlertControl.SetSeverity(alertState.Severity);
                if (alertState.ShowCooldown)
                    existingAlertControl.Cooldown = alertState.Cooldown;
            }
            else
            {
                // If we wanna move some Alerts into another UI.
                var alertControlsContainer = EnsureControlsContainer(alertKey);

                if (existingAlertControl != null)
                    alertControlsContainer.Children.Remove(existingAlertControl);

                // this is a new alert + alert key or just a different alert with the same
                // key, create the control and add it in the appropriate order
                var newAlertControl = CreateAlertControl(newAlert, alertState);

                //TODO: Can the presenter sort the states before giving it to us?
                if (alertOrderPrototype != null)
                {
                    var added = false;
                    foreach (var alertControl in alertControlsContainer.Children)
                    {
                        if (alertOrderPrototype.Compare(newAlert, ((AlertControl) alertControl).Alert) >= 0)
                            continue;

                        var idx = alertControl.GetPositionInParent();
                        alertControlsContainer.Children.Add(newAlertControl);
                        newAlertControl.SetPositionInParent(idx);
                        added = true;
                        break;
                    }

                    if (!added)
                        alertControlsContainer.Children.Add(newAlertControl);
                }
                else
                {
                    alertControlsContainer.Children.Add(newAlertControl);
                }

                _alertControls[newAlert.AlertKey] = newAlertControl;
            }
        }
    }

    private AlertControl CreateAlertControl(AlertPrototype alert, AlertState alertState)
    {
        (TimeSpan, TimeSpan)? cooldown = null;
        if (alertState.ShowCooldown)
            cooldown = alertState.Cooldown;

        AlertControl? alertControl;

        _prototypeManager.TryIndex<AlertCategoryPrototype>(alert.Category, out var alertCategory);
        var category = alertCategory;

        // Try found any alert groups and make specified buttos.
        if (category != null)
        {
            switch (category.Group)
            {
                case "Intents":
                    alertControl = new AlertControl(alert, alertState.Severity, 2, 16, 1f)
                    {
                        Cooldown = cooldown
                    };

                    // Set names for keyboard binds
                    switch (alert.ID)
                    {
                        case "IntentHelp":
                            alertControl.Name = "0";
                            break;
                        case "IntentDisarm":
                            alertControl.Name = "1";
                            break;
                        case "IntentGrab":
                            alertControl.Name = "2";
                            break;
                        case "IntentHarm":
                            alertControl.Name = "3";
                            break;
                    }

                    alertControl.OnPressed += AlertControlPressed;
                    return alertControl;
                case "NativeActions":
                    alertControl = new AlertControl(alert, alertState.Severity, 2, 32, 1f)
                    {
                        Cooldown = cooldown
                    };
                    alertControl.OnPressed += AlertControlPressed;
                    return alertControl;
                case "MainInfo":
                    alertControl = new AlertControl(alert, alertState.Severity, 2, 32, 1f)
                    {
                        Cooldown = cooldown
                    };
                    alertControl.OnPressed += AlertControlPressed;
                    return alertControl;
            }
        }

        // If butto is not specified by the group - it's normal alert.
        alertControl = new AlertControl(alert, alertState.Severity)
        {
            Cooldown = cooldown
        };
        alertControl.OnPressed += AlertControlPressed;
        return alertControl;
    }

    private void AlertControlPressed(BaseButton.ButtonEventArgs args)
    {
        if (args.Button is not AlertControl control)
            return;

        if (args.Event.Function != EngineKeyFunctions.UIClick)
            return;

        AlertPressed?.Invoke(this, control.Alert.ID);
    }
}
